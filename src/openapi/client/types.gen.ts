// This file is auto-generated by @hey-api/openapi-ts

/**
 * v4 features an advanced economy model under the hood.
 * Accountings are implemented as a common interface for issuing and receiving Transactions,
 * which allows different resources to have money-capabalities.
 * \
 * \
 * Many different actions can trigger changes in Accountings, such as GatewayCheckouts being successfully charged.
 */
export type Accounting = {
    id?: number;
    /**
     * The preferred currency for monetary operations.\
     * 3-letter ISO 4217 currency code.
     */
    currency?: string;
    /**
     * The money currently held by the Accounting.
     */
    balance?: Money;
    /**
     * The resource owning this Accounting.
     */
    readonly owner?: string;
};

/**
 * v4 features an advanced economy model under the hood.
 * Accountings are implemented as a common interface for issuing and receiving Transactions,
 * which allows different resources to have money-capabalities.
 * \
 * \
 * Many different actions can trigger changes in Accountings, such as GatewayCheckouts being successfully charged.
 */
export type AccountingJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    id?: number;
    /**
     * The preferred currency for monetary operations.\
     * 3-letter ISO 4217 currency code.
     */
    currency?: string;
    /**
     * The money currently held by the Accounting.
     */
    balance?: MoneyJsonld;
    /**
     * The resource owning this Accounting.
     */
    readonly owner?: string;
};

/**
 * AccountingBalancePoints represent a dated aggregate Accounting balance.\
 * \
 * Each point is the sum of money at incoming and outgoing transactions in an Accounting for a period of time,
 * you can query multiple balance points to obtain the evolution of the Accounting's balance over time.
 */
export type AccountingBalancePoint = {
    /**
     * The start date for items aggregated in this point.
     */
    start?: string;
    /**
     * The end date for items aggregated in this point. Not inclusive.
     */
    end?: string;
    /**
     * Resulting balance for items in this point.
     */
    balance?: Money;
    /**
     * The number of items aggregated in this point.
     */
    length?: number;
};

/**
 * AccountingBalancePoints represent a dated aggregate Accounting balance.\
 * \
 * Each point is the sum of money at incoming and outgoing transactions in an Accounting for a period of time,
 * you can query multiple balance points to obtain the evolution of the Accounting's balance over time.
 */
export type AccountingBalancePointJsonld = {
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * The start date for items aggregated in this point.
     */
    start?: string;
    /**
     * The end date for items aggregated in this point. Not inclusive.
     */
    end?: string;
    /**
     * Resulting balance for items in this point.
     */
    balance?: MoneyJsonld;
    /**
     * The number of items aggregated in this point.
     */
    length?: number;
};

/**
 * AccountingTransactions represent a movement of money from one Accounting (origin) into another (target).\
 * \
 * When a transaction targets an Accounting it means that the Accounting receives it, this will add to that Accounting.
 * When a transaction originates from an Accounting the Accounting issues the transaction and it will deduct from it if,
 * specially when the transaction comes from a GatewayCharge processed by the `wallet` Gateway.\
 * \
 * AccountingTransactions are generated for each GatewayCharge in a GatewayCheckout once it becomes successful.
 */
export type AccountingTransaction = {
    readonly id?: number;
    /**
     * The monetary value received at target and issued at origin.
     */
    money?: Money;
    /**
     * The Accounting from which the Transaction comes from.
     */
    origin?: string;
    /**
     * The Accounting where the Transaction goes to.
     */
    target?: string;
};

/**
 * AccountingTransactions represent a movement of money from one Accounting (origin) into another (target).\
 * \
 * When a transaction targets an Accounting it means that the Accounting receives it, this will add to that Accounting.
 * When a transaction originates from an Accounting the Accounting issues the transaction and it will deduct from it if,
 * specially when the transaction comes from a GatewayCharge processed by the `wallet` Gateway.\
 * \
 * AccountingTransactions are generated for each GatewayCharge in a GatewayCheckout once it becomes successful.
 */
export type AccountingTransactionJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The monetary value received at target and issued at origin.
     */
    money?: MoneyJsonld;
    /**
     * The Accounting from which the Transaction comes from.
     */
    origin?: string;
    /**
     * The Accounting where the Transaction goes to.
     */
    target?: string;
};

export type ApiResourceMoney = {
    /**
     * An amount of currency.\
     * Expressed as the minor unit, e.g: cents, pennies, etc.
     */
    amount: number;
    /**
     * 3-letter ISO 4217 currency code.
     */
    currency: string;
};

export type ApiResourceMoneyJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * An amount of currency.\
     * Expressed as the minor unit, e.g: cents, pennies, etc.
     */
    amount: number;
    /**
     * 3-letter ISO 4217 currency code.
     */
    currency: string;
};

export type Budget = {
    /**
     * A summary of the minimum budget. As described by items with specified minimum money.
     */
    minimum?: BudgetSummary;
    /**
     * A summary of the optimum, minimum included, budget. As described by items with specified optimum money plus minimum money.
     */
    optimum?: BudgetSummary;
};

export type BudgetJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * A summary of the minimum budget. As described by items with specified minimum money.
     */
    minimum?: BudgetSummaryJsonld;
    /**
     * A summary of the optimum, minimum included, budget. As described by items with specified optimum money plus minimum money.
     */
    optimum?: BudgetSummaryJsonld;
};

export type BudgetSummary = {
    /**
     * The total money by the included items.
     */
    money?: Money;
    /**
     * The total money of type 'task'.
     */
    task?: Money;
    /**
     * The total money of type 'material'.
     */
    material?: Money;
    /**
     * The total money of type 'infrastructure'.
     */
    infra?: Money;
};

export type BudgetSummaryJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * The total money by the included items.
     */
    money?: MoneyJsonld;
    /**
     * The total money of type 'task'.
     */
    task?: MoneyJsonld;
    /**
     * The total money of type 'material'.
     */
    material?: MoneyJsonld;
    /**
     * The total money of type 'infrastructure'.
     */
    infra?: MoneyJsonld;
};

/**
 * Unprocessable entity
 */
export type ConstraintViolationJson = {
    status?: number;
    violations?: Array<{
        /**
         * The property path of the violation
         */
        propertyPath?: string;
        /**
         * The message associated with the violation
         */
        message?: string;
    }>;
    readonly detail?: string;
    readonly type?: string;
    readonly title?: string | null;
    readonly instance?: string | null;
};

/**
 * Unprocessable entity
 */
export type ConstraintViolationJsonldJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    status?: number;
    violations?: Array<{
        /**
         * The property path of the violation
         */
        propertyPath?: string;
        /**
         * The message associated with the violation
         */
        message?: string;
    }>;
    readonly detail?: string;
    readonly description?: string;
    readonly type?: string;
    readonly title?: string | null;
    readonly instance?: string | null;
};

/**
 * A representation of common errors.
 */
export type _Error = {
    /**
     * A short, human-readable summary of the problem.
     */
    readonly title?: string | null;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    readonly detail?: string | null;
    status?: number;
    /**
     * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     */
    readonly instance?: string | null;
    /**
     * A URI reference that identifies the problem type
     */
    readonly type?: string;
};

/**
 * A representation of common errors.
 */
export type ErrorJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * A short, human-readable summary of the problem.
     */
    readonly title?: string | null;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    readonly detail?: string | null;
    status?: number;
    /**
     * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     */
    readonly instance?: string | null;
    /**
     * A URI reference that identifies the problem type
     */
    readonly type?: string;
    readonly description?: string | null;
};

/**
 * Gateways represent payment services used to perform the necessary payments for Transactions between Accounts.\
 * \
 * For each Gateway there is an internal implementation that handles the creation and validation of Transactions between Accounts.
 * These implementations make use of external or internal services to gather the funds that are inside a Transaction,
 * perform corroboration of funds and store the Transactions into the system.
 */
export type Gateway = {
    name?: string;
    supports?: Array<'single' | 'recurring'>;
};

/**
 * Gateways represent payment services used to perform the necessary payments for Transactions between Accounts.\
 * \
 * For each Gateway there is an internal implementation that handles the creation and validation of Transactions between Accounts.
 * These implementations make use of external or internal services to gather the funds that are inside a Transaction,
 * perform corroboration of funds and store the Transactions into the system.
 */
export type GatewayJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    name?: string;
    supports?: Array<'single' | 'recurring'>;
};

/**
 * A Charge represents a payment item to be included in a Checkout for payment at a Gateway.
 */
export type GatewayCharge = {
    readonly id?: number | null;
    /**
     * The Checkout to which this Charge item belongs to.
     */
    readonly checkout?: string;
    /**
     * How this item should be processed by the Gateway.\
     * \
     * `single` is for one time payments.\
     * `recurring` is for payments repeated over time.
     */
    type: 'single' | 'recurring';
    /**
     * A short, descriptive string for this charge item.\
     * May be displayed to the payer.
     */
    title: string;
    /**
     * Detailed information about the charge item.\
     * May be displayed to the payer.
     */
    description?: string | null;
    /**
     * The Accounting receiving the money after a successful payment.
     */
    target: string;
    /**
     * The money to-be-paid for this item at the Gateway.
     */
    money: Money;
    /**
     * The status of the charge item with the Gateway.
     */
    status: 'in_pending' | 'charged' | 'to_refund' | 'refunded';
    dateCreated?: string;
    dateUpdated?: string;
};

/**
 * A Charge represents a payment item to be included in a Checkout for payment at a Gateway.
 */
export type GatewayChargeChargeUpdationDto = {
    /**
     * The unique identifier for the charge.
     */
    id?: number;
    /**
     * The type of the charge.
     */
    type?: 'single' | 'recurring';
    /**
     * The title or name of the charge.
     */
    title?: string;
    /**
     * A detailed description of the charge.
     */
    description?: string;
    /**
     * The current payment status of the charge.
     */
    status?: 'in_pending' | 'charged' | 'to_refund' | 'refunded';
};

/**
 * A Charge represents a payment item to be included in a Checkout for payment at a Gateway.
 */
export type GatewayChargeJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number | null;
    /**
     * The Checkout to which this Charge item belongs to.
     */
    readonly checkout?: string;
    /**
     * How this item should be processed by the Gateway.\
     * \
     * `single` is for one time payments.\
     * `recurring` is for payments repeated over time.
     */
    type: 'single' | 'recurring';
    /**
     * A short, descriptive string for this charge item.\
     * May be displayed to the payer.
     */
    title: string;
    /**
     * Detailed information about the charge item.\
     * May be displayed to the payer.
     */
    description?: string | null;
    /**
     * The Accounting receiving the money after a successful payment.
     */
    target: string;
    /**
     * The money to-be-paid for this item at the Gateway.
     */
    money: MoneyJsonld;
    /**
     * The status of the charge item with the Gateway.
     */
    status: 'in_pending' | 'charged' | 'to_refund' | 'refunded';
    dateCreated?: string;
    dateUpdated?: string;
};

/**
 * A GatewayCheckout represents a payment session with a Gateway.
 */
export type GatewayCheckout = {
    readonly id?: number;
    /**
     * The desired Gateway to checkout with.
     */
    gateway: string;
    /**
     * The Accounting paying for the charges.
     */
    origin: string;
    /**
     * A list of the payment items to be charged to the origin.
     */
    charges: Array<GatewayCharge>;
    /**
     * Gateways will redirect the user back to the v4 API,
     * which will then redirect the user to this address.\
     * \
     * An URL query param `checkoutId` with the Checkout ID value
     * will be appended on the redirection.
     */
    returnUrl: string;
    /**
     * The strategy chosen by the User to decide where the money will go to
     * in the event that one Charge needs to be returned.
     */
    refund?: 'to_wallet' | 'to_gateway';
    /**
     * The status of this Checkout, as confirmed by the Gateway.
     */
    status?: 'in_pending' | 'charged';
    /**
     * A list of related hyperlinks, as provided by the Gateway.
     */
    readonly links?: Array<Link>;
    /**
     * A list of related tracking codes and numbers, as provided by the Gateway.
     */
    readonly trackings?: Array<Tracking>;
    dateCreated?: string;
    dateUpdated?: string;
};

/**
 * A GatewayCheckout represents a payment session with a Gateway.
 */
export type GatewayCheckoutCheckoutUpdationDto = {
    readonly id?: number;
    /**
     * The strategy chosen by the User to decide where the money will go to
     * in the event that one Charge needs to be returned.
     */
    refund?: 'to_wallet' | 'to_gateway';
};

/**
 * A GatewayCheckout represents a payment session with a Gateway.
 */
export type GatewayCheckoutJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The desired Gateway to checkout with.
     */
    gateway: string;
    /**
     * The Accounting paying for the charges.
     */
    origin: string;
    /**
     * A list of the payment items to be charged to the origin.
     */
    charges: Array<GatewayChargeJsonld>;
    /**
     * Gateways will redirect the user back to the v4 API,
     * which will then redirect the user to this address.\
     * \
     * An URL query param `checkoutId` with the Checkout ID value
     * will be appended on the redirection.
     */
    returnUrl: string;
    /**
     * The strategy chosen by the User to decide where the money will go to
     * in the event that one Charge needs to be returned.
     */
    refund?: 'to_wallet' | 'to_gateway';
    /**
     * The status of this Checkout, as confirmed by the Gateway.
     */
    status?: 'in_pending' | 'charged';
    /**
     * A list of related hyperlinks, as provided by the Gateway.
     */
    readonly links?: Array<LinkJsonld>;
    /**
     * A list of related tracking codes and numbers, as provided by the Gateway.
     */
    readonly trackings?: Array<TrackingJsonld>;
    dateCreated?: string;
    dateUpdated?: string;
};

export type Link = {
    /**
     * The complete target URL.
     */
    href?: string;
    /**
     * The link relation type, which serves as an ID for a link that unambiguously describes the semantics of the link.
     */
    rel?: string;
    /**
     * The HTTP method required to make the related call.
     */
    method?: string;
    /**
     * The type of the link indicates who is the intended user of a link.\
     * `debug` links are for developers and platform maintainers to get useful information about the checkout.\
     * `payment` links are for end-users who must visit this link to complete the checkout.
     */
    type?: 'debug' | 'payment';
};

export type LinkJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * The complete target URL.
     */
    href?: string;
    /**
     * The link relation type, which serves as an ID for a link that unambiguously describes the semantics of the link.
     */
    rel?: string;
    /**
     * The HTTP method required to make the related call.
     */
    method?: string;
    /**
     * The type of the link indicates who is the intended user of a link.\
     * `debug` links are for developers and platform maintainers to get useful information about the checkout.\
     * `payment` links are for end-users who must visit this link to complete the checkout.
     */
    type?: 'debug' | 'payment';
};

/**
 * A MatchCall is a managed event which accepts MatchCallSubmissions from Projects to receive *matchfunding* financement.
 * This means money going to a Project in a MatchCall can be matched with funds from the MatchCall accounting.
 * \
 * \
 * MatchCallSubmissions from Projects can be accepted or rejected by the managers.
 * \
 * \
 * How and when does a MatchCall match funds is determined by the MatchStrategy.
 * Everytime there is a Charge item going to a Project accepted in a MatchCall the strategy is evaluated for matching.
 * The strategy defines a series of rules that determine if the Charge is eligible for triggering the matching of funds.
 * When a Charge is to be matched the strategy uses a MatchFormula,
 * which is a predefined implementation for common mathematical operations used to match money.
 * The formula is fine-tuned in the strategy by defining the variables in the formula.
 */
export type MatchCall = {
    readonly id?: number;
    /**
     * The Accounting which holds and spends the funds for this MatchCall.
     */
    readonly accounting?: string;
    /**
     * The MatchStrategy defines the match behaviour for this MatchCall.
     */
    readonly strategy?: string;
    /**
     * A list of the MatchCallSubmissions received by this MatchCall.
     */
    readonly submissions?: Array<string>;
    /**
     * A list of Users who can modify this MatchCall.
     */
    managers?: Array<string>;
    /**
     * Main display title.
     */
    title: string;
    /**
     * Long-form secondary display text.
     */
    description?: string;
    /**
     * Codes for the territory of interest in this MatchCall.
     */
    territory: Territory;
    /**
     * The current status of the MatchCall.
     */
    status?: 'in_editing' | 'in_calling' | 'in_matchmaking' | 'to_closed' | 'closed';
};

/**
 * A MatchCall is a managed event which accepts MatchCallSubmissions from Projects to receive *matchfunding* financement.
 * This means money going to a Project in a MatchCall can be matched with funds from the MatchCall accounting.
 * \
 * \
 * MatchCallSubmissions from Projects can be accepted or rejected by the managers.
 * \
 * \
 * How and when does a MatchCall match funds is determined by the MatchStrategy.
 * Everytime there is a Charge item going to a Project accepted in a MatchCall the strategy is evaluated for matching.
 * The strategy defines a series of rules that determine if the Charge is eligible for triggering the matching of funds.
 * When a Charge is to be matched the strategy uses a MatchFormula,
 * which is a predefined implementation for common mathematical operations used to match money.
 * The formula is fine-tuned in the strategy by defining the variables in the formula.
 */
export type MatchCallJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The Accounting which holds and spends the funds for this MatchCall.
     */
    readonly accounting?: string;
    /**
     * The MatchStrategy defines the match behaviour for this MatchCall.
     */
    readonly strategy?: string;
    /**
     * A list of the MatchCallSubmissions received by this MatchCall.
     */
    readonly submissions?: Array<string>;
    /**
     * A list of Users who can modify this MatchCall.
     */
    managers?: Array<string>;
    /**
     * Main display title.
     */
    title: string;
    /**
     * Long-form secondary display text.
     */
    description?: string;
    /**
     * Codes for the territory of interest in this MatchCall.
     */
    territory: TerritoryJsonld;
    /**
     * The current status of the MatchCall.
     */
    status?: 'in_editing' | 'in_calling' | 'in_matchmaking' | 'to_closed' | 'closed';
};

/**
 * MatchCallSubmissions represent the will of a Project to be held under a MatchCall and receive matchfunding financement.
 */
export type MatchCallSubmission = {
    readonly id?: number;
    /**
     * The MatchCall to which this MatchCallSubmission belongs to.
     */
    readonly call?: string;
    /**
     * The Project that applied for the MatchCall.
     */
    readonly project?: string;
    /**
     * The status of the Project's application for the MatchCall.\
     * Only MatchCallSubmissions with an status `accepted` will receive matchfunding.
     */
    status?: 'to_review' | 'in_review' | 'accepted' | 'rejected';
};

/**
 * MatchCallSubmissions represent the will of a Project to be held under a MatchCall and receive matchfunding financement.
 */
export type MatchCallSubmissionMatchCallSubmissionCreationDto = {
    /**
     * The MatchCall to which this MatchCallSubmission belongs to.
     */
    call: string;
    /**
     * The Project that applied for the MatchCall.
     */
    project: string;
};

/**
 * MatchCallSubmissions represent the will of a Project to be held under a MatchCall and receive matchfunding financement.
 */
export type MatchCallSubmissionMatchCallSubmissionCreationDtoJsonld = {
    /**
     * The MatchCall to which this MatchCallSubmission belongs to.
     */
    call: string;
    /**
     * The Project that applied for the MatchCall.
     */
    project: string;
};

/**
 * MatchCallSubmissions represent the will of a Project to be held under a MatchCall and receive matchfunding financement.
 */
export type MatchCallSubmissionJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The MatchCall to which this MatchCallSubmission belongs to.
     */
    readonly call?: string;
    /**
     * The Project that applied for the MatchCall.
     */
    readonly project?: string;
    /**
     * The status of the Project's application for the MatchCall.\
     * Only MatchCallSubmissions with an status `accepted` will receive matchfunding.
     */
    status?: 'to_review' | 'in_review' | 'accepted' | 'rejected';
};

/**
 * A MatchFormula is a predefined code implementation for matching funds in Transactions under a MatchCall.
 * MatchFormulas can be chosen by the managers in a MatchCall and their behaviour fine-tuned.
 */
export type MatchFormula = {
    readonly name?: string;
    /**
     * The underlying math expressed as a common-notation formula.
     */
    readonly expression?: string;
};

/**
 * A MatchFormula is a predefined code implementation for matching funds in Transactions under a MatchCall.
 * MatchFormulas can be chosen by the managers in a MatchCall and their behaviour fine-tuned.
 */
export type MatchFormulaJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly name?: string;
    /**
     * The underlying math expressed as a common-notation formula.
     */
    readonly expression?: string;
};

/**
 * A MatchRule is a predefined code implementation for validating
 * that a match making condition is met when there is a Charge to be matched.
 */
export type MatchRule = {
    readonly name?: string;
    /**
     * A plain-text description about what the rules validates for.
     */
    readonly description?: string;
};

/**
 * A MatchRule is a predefined code implementation for validating
 * that a match making condition is met when there is a Charge to be matched.
 */
export type MatchRuleJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly name?: string;
    /**
     * A plain-text description about what the rules validates for.
     */
    readonly description?: string;
};

/**
 * A MatchStrategy defines how will a MatchCall perform the match-making process.
 * \
 * The match-making flow is:
 * 1. A Project accepted in a MatchCall receives a successful Charge.
 * 2. The match-making loads the MatchCall's MatchStrategy.
 * 3. The MatchStrategy rules are executed, if one rule fails the match-making is cancelled for the Charge.
 * 3. The MatchStrategy formula function is passed the respective limit, factor and money of the MatchAgainst.
 * 4. The result of the MatchStrategy formula function execution is put in a Transaction from the MatchCall to the Project.
 */
export type MatchStrategy = {
    readonly call?: string;
    /**
     * The MatchRules used to decide if the match making strategy should be executed or not.
     */
    rules?: Array<string>;
    /**
     * The MatchFormula used to calculate matched funds.
     */
    formula: string;
    /**
     * The assigned maximum amount of funding that will be given by the MatchFormula per operation.
     */
    limit: ApiResourceMoney;
    /**
     * The `x` factor used to calculate the resulting match of funds with the MatchFormula.
     */
    factor: number;
    /**
     * The money to be matched by the formula is
     * - `charge` the money in the Charge item
     * - `budget_min` the minimum in the Project's budget
     * - `budget_opt` the optimum in the Project's budget.
     */
    against?: 'charge' | 'budget_min' | 'budget_opt';
};

/**
 * A MatchStrategy defines how will a MatchCall perform the match-making process.
 * \
 * The match-making flow is:
 * 1. A Project accepted in a MatchCall receives a successful Charge.
 * 2. The match-making loads the MatchCall's MatchStrategy.
 * 3. The MatchStrategy rules are executed, if one rule fails the match-making is cancelled for the Charge.
 * 3. The MatchStrategy formula function is passed the respective limit, factor and money of the MatchAgainst.
 * 4. The result of the MatchStrategy formula function execution is put in a Transaction from the MatchCall to the Project.
 */
export type MatchStrategyJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly call?: string;
    /**
     * The MatchRules used to decide if the match making strategy should be executed or not.
     */
    rules?: Array<string>;
    /**
     * The MatchFormula used to calculate matched funds.
     */
    formula: string;
    /**
     * The assigned maximum amount of funding that will be given by the MatchFormula per operation.
     */
    limit: ApiResourceMoneyJsonld;
    /**
     * The `x` factor used to calculate the resulting match of funds with the MatchFormula.
     */
    factor: number;
    /**
     * The money to be matched by the formula is
     * - `charge` the money in the Charge item
     * - `budget_min` the minimum in the Project's budget
     * - `budget_opt` the optimum in the Project's budget.
     */
    against?: 'charge' | 'budget_min' | 'budget_opt';
};

export type Money = {
    /**
     * An amount of currency.\
     * Expressed as the minor unit, e.g: cents, pennies, etc.
     */
    amount?: number | null;
    /**
     * 3-letter ISO 4217 currency code.
     */
    currency?: string | null;
};

export type MoneyJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * An amount of currency.\
     * Expressed as the minor unit, e.g: cents, pennies, etc.
     */
    amount?: number | null;
    /**
     * 3-letter ISO 4217 currency code.
     */
    currency?: string | null;
};

/**
 * Sometimes an Organization is behind a User account,
 * we keep their data separated from the User record to allow for other User types,
 * like the ones owned by an individual, to exist all at the same level.\
 * \
 * All Organization records are only visible to their respective owners and platform admins.
 * Sensitive data is encrypted before being stored in the database.
 */
export type Organization = {
    readonly user?: string;
    /**
     * ID for tax purposes. e.g: NIF (formerly CIF), Umsatzsteuer-Id, EID, etc.
     */
    taxId: string;
    /**
     * Organization legal name before government,
     * as it appears on legal documents issued by or for this organization.\
     * Will be used as last option for the display name of the User.
     */
    legalName: string;
    /**
     * The name under which the organization presents itself.\
     * Might be similar to the legal name or completely different.\
     * Will be used as display name for the User when present.
     */
    businessName?: string;
};

/**
 * Sometimes an Organization is behind a User account,
 * we keep their data separated from the User record to allow for other User types,
 * like the ones owned by an individual, to exist all at the same level.\
 * \
 * All Organization records are only visible to their respective owners and platform admins.
 * Sensitive data is encrypted before being stored in the database.
 */
export type OrganizationJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly user?: string;
    /**
     * ID for tax purposes. e.g: NIF (formerly CIF), Umsatzsteuer-Id, EID, etc.
     */
    taxId: string;
    /**
     * Organization legal name before government,
     * as it appears on legal documents issued by or for this organization.\
     * Will be used as last option for the display name of the User.
     */
    legalName: string;
    /**
     * The name under which the organization presents itself.\
     * Might be similar to the legal name or completely different.\
     * Will be used as display name for the User when present.
     */
    businessName?: string;
};

/**
 * Most times a real person is behind a User account,
 * we keep their data separated from the User record to allow for other User types,
 * like the ones owned by an organization, to exist all at the same level.\
 * \
 * All Person records are only visible to their respective owners and platform admins.
 * Sensitive personal data is encrypted before being stored in the database.
 */
export type Person = {
    readonly user?: string;
    /**
     * Personal ID for tax purposes. e.g: NIF, Steuer-ID, SSN, ITIN, etc.
     */
    taxId?: string;
    /**
     * First-part of the name of the person,
     * in most western conventions this is the given name(s). e.g: John, Juan, etc.
     */
    firstName?: string;
    /**
     * Last-part of the name of the person,
     * in most western conventions this is the family name(s). e.g: Smith, Herrera García, etc.
     */
    lastName?: string;
};

/**
 * Most times a real person is behind a User account,
 * we keep their data separated from the User record to allow for other User types,
 * like the ones owned by an organization, to exist all at the same level.\
 * \
 * All Person records are only visible to their respective owners and platform admins.
 * Sensitive personal data is encrypted before being stored in the database.
 */
export type PersonJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly user?: string;
    /**
     * Personal ID for tax purposes. e.g: NIF, Steuer-ID, SSN, ITIN, etc.
     */
    taxId?: string;
    /**
     * First-part of the name of the person,
     * in most western conventions this is the given name(s). e.g: John, Juan, etc.
     */
    firstName?: string;
    /**
     * Last-part of the name of the person,
     * in most western conventions this is the family name(s). e.g: Smith, Herrera García, etc.
     */
    lastName?: string;
};

/**
 * Projects describe a User-owned, community-led event that is to be discovered, developed and funded by the community.
 */
export type Project = {
    readonly id?: number;
    /**
     * A unique, non white space, string identifier for this Project.
     */
    readonly slug?: string;
    /**
     * The Accounting holding the funds raised by this Project.
     */
    readonly accounting?: string;
    /**
     * The User who owns this Project.
     */
    readonly owner?: string;
    /**
     * Main headline for the Project.
     */
    title: string;
    /**
     * Secondary headline for the Project.
     */
    subtitle: string;
    /**
     * On `minimum`, Project will campaign until the minimum deadline.\
     * On `optimum`, Project will campaing until the minimum deadline,
     * and then until the optimum deadline if it did raise the minimum.
     */
    deadline?: 'minimum' | 'optimum';
    /**
     * Deadlines and important Project dates.
     */
    calendar?: ProjectCalendar;
    /**
     * One of the available categories.
     */
    category: 'solidary' | 'libre-software' | 'employment' | 'design' | 'journalism' | 'education' | 'culture' | 'ecology' | 'health-and-cares' | 'open-data' | 'democracy' | 'equity';
    /**
     * ISO 3166 data about the Project's territory of interest.
     */
    territory: Territory;
    /**
     * Free-form rich text description for the Project.
     */
    description: string;
    /**
     * Extracted embedding data from the Project's video.
     */
    video?: ProjectVideo;
    /**
     * The status of a Project represents how far it is in it's life-cycle.
     */
    status?: 'in_draft' | 'to_review' | 'in_review' | 'in_editing' | 'rejected' | 'in_campaign' | 'unfunded' | 'in_funding' | 'funded';
    /**
     * List of the ProjectRewards this Project offers.
     */
    readonly rewards?: Array<string>;
    /**
     * A detailed breakdown of the budget for this Project, as described by the associated BudgetItems.
     */
    budget?: Budget;
    /**
     * A list of the BudgetItems composing the budget of this Project.
     */
    readonly budgetItems?: Array<string>;
    /**
     * A list of the ProjectUpdates this Project has.
     */
    readonly updates?: Array<string>;
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

/**
 * Projects describe a User-owned, community-led event that is to be discovered, developed and funded by the community.
 */
export type ProjectProjectCreationDto = {
    /**
     * Main headline for the Project. Must include at least one character between a-Z.
     */
    title: string;
    /**
     * Secondary headline for the Project.
     */
    subtitle: string;
    /**
     * One of the available categories.
     */
    category: 'solidary' | 'libre-software' | 'employment' | 'design' | 'journalism' | 'education' | 'culture' | 'ecology' | 'health-and-cares' | 'open-data' | 'democracy' | 'equity';
    /**
     * ISO 3166 data about the Project's territory of interest.
     */
    territory: Territory;
    /**
     * Free-form rich text description for the Project.
     */
    description: string;
    /**
     * On `minimum`, Project will campaign until the minimum deadline.\
     * On `optimum`, Project will campaing until the minimum deadline,
     * and then until the optimum deadline if it did raise the minimum.
     */
    deadline?: 'minimum' | 'optimum';
    /**
     * A URL to a video showcasing the Project.
     */
    video?: string;
};

/**
 * Projects describe a User-owned, community-led event that is to be discovered, developed and funded by the community.
 */
export type ProjectProjectCreationDtoJsonld = {
    /**
     * Main headline for the Project. Must include at least one character between a-Z.
     */
    title: string;
    /**
     * Secondary headline for the Project.
     */
    subtitle: string;
    /**
     * One of the available categories.
     */
    category: 'solidary' | 'libre-software' | 'employment' | 'design' | 'journalism' | 'education' | 'culture' | 'ecology' | 'health-and-cares' | 'open-data' | 'democracy' | 'equity';
    /**
     * ISO 3166 data about the Project's territory of interest.
     */
    territory: TerritoryJsonld;
    /**
     * Free-form rich text description for the Project.
     */
    description: string;
    /**
     * On `minimum`, Project will campaign until the minimum deadline.\
     * On `optimum`, Project will campaing until the minimum deadline,
     * and then until the optimum deadline if it did raise the minimum.
     */
    deadline?: 'minimum' | 'optimum';
    /**
     * A URL to a video showcasing the Project.
     */
    video?: string;
};

/**
 * Projects describe a User-owned, community-led event that is to be discovered, developed and funded by the community.
 */
export type ProjectProjectUpdationDto = {
    readonly id?: number;
    /**
     * Main headline for the Project.
     */
    title?: string;
    /**
     * Secondary headline for the Project.
     */
    subtitle?: string;
    /**
     * One of the available categories.
     */
    category?: 'solidary' | 'libre-software' | 'employment' | 'design' | 'journalism' | 'education' | 'culture' | 'ecology' | 'health-and-cares' | 'open-data' | 'democracy' | 'equity';
    /**
     * ISO 3166 data about the Project's territory of interest.
     */
    territory?: Territory;
    /**
     * Free-form rich text description for the Project.
     */
    description?: string;
    /**
     * On `minimum`, Project will campaign until the minimum deadline.\
     * On `optimum`, Project will campaing until the minimum deadline,
     * and then until the optimum deadline if it did raise the minimum.
     */
    deadline?: 'minimum' | 'optimum';
    /**
     * A URL to a video showcasing the Project.
     */
    video?: string;
    /**
     * The status of a Project represents how far it is in it's life-cycle.
     */
    status?: 'in_draft' | 'to_review' | 'in_review' | 'in_editing' | 'rejected' | 'in_campaign' | 'unfunded' | 'in_funding' | 'funded';
};

/**
 * Projects describe a User-owned, community-led event that is to be discovered, developed and funded by the community.
 */
export type ProjectJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * A unique, non white space, string identifier for this Project.
     */
    readonly slug?: string;
    /**
     * The Accounting holding the funds raised by this Project.
     */
    readonly accounting?: string;
    /**
     * The User who owns this Project.
     */
    readonly owner?: string;
    /**
     * Main headline for the Project.
     */
    title: string;
    /**
     * Secondary headline for the Project.
     */
    subtitle: string;
    /**
     * On `minimum`, Project will campaign until the minimum deadline.\
     * On `optimum`, Project will campaing until the minimum deadline,
     * and then until the optimum deadline if it did raise the minimum.
     */
    deadline?: 'minimum' | 'optimum';
    /**
     * Deadlines and important Project dates.
     */
    calendar?: ProjectCalendarJsonld;
    /**
     * One of the available categories.
     */
    category: 'solidary' | 'libre-software' | 'employment' | 'design' | 'journalism' | 'education' | 'culture' | 'ecology' | 'health-and-cares' | 'open-data' | 'democracy' | 'equity';
    /**
     * ISO 3166 data about the Project's territory of interest.
     */
    territory: TerritoryJsonld;
    /**
     * Free-form rich text description for the Project.
     */
    description: string;
    /**
     * Extracted embedding data from the Project's video.
     */
    video?: ProjectVideoJsonld;
    /**
     * The status of a Project represents how far it is in it's life-cycle.
     */
    status?: 'in_draft' | 'to_review' | 'in_review' | 'in_editing' | 'rejected' | 'in_campaign' | 'unfunded' | 'in_funding' | 'funded';
    /**
     * List of the ProjectRewards this Project offers.
     */
    readonly rewards?: Array<string>;
    /**
     * A detailed breakdown of the budget for this Project, as described by the associated BudgetItems.
     */
    budget?: BudgetJsonld;
    /**
     * A list of the BudgetItems composing the budget of this Project.
     */
    readonly budgetItems?: Array<string>;
    /**
     * A list of the ProjectUpdates this Project has.
     */
    readonly updates?: Array<string>;
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

/**
 * A Project's budget is composed via BudgetItem records.\
 * \
 * Each BudgetItem describes one specific monetary necessity. The total budget of a Project is then calculated from the related BudgetItems.
 */
export type ProjectBudgetItem = {
    readonly id?: number;
    project?: string;
    /**
     * The type of need this item solves.
     */
    type: 'infrastructure' | 'material' | 'task';
    /**
     * A short, descriptive string for the item.
     */
    title: string;
    /**
     * Detailed information about the item.
     */
    description: string;
    /**
     * The amount of money required for this item.
     */
    money: ApiResourceMoney;
    /**
     * Defines the budget category for this item within the project.
     */
    deadline: 'minimum' | 'optimum';
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

/**
 * A Project's budget is composed via BudgetItem records.\
 * \
 * Each BudgetItem describes one specific monetary necessity. The total budget of a Project is then calculated from the related BudgetItems.
 */
export type ProjectBudgetItemJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    project?: string;
    /**
     * The type of need this item solves.
     */
    type: 'infrastructure' | 'material' | 'task';
    /**
     * A short, descriptive string for the item.
     */
    title: string;
    /**
     * Detailed information about the item.
     */
    description: string;
    /**
     * The amount of money required for this item.
     */
    money: ApiResourceMoneyJsonld;
    /**
     * Defines the budget category for this item within the project.
     */
    deadline: 'minimum' | 'optimum';
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

export type ProjectCalendar = {
    /**
     * The date at which the Project started campaigning.
     */
    release?: string | null;
    /**
     * 40 days after the date of release.\
     * \
     * The minimum budget must be raised by the end of this date.\
     * Failure to do so will move the Project out of status `in_campaign` into status `unfunded`.
     */
    minimum?: string | null;
    /**
     * 40 days after the minimum deadline. Optional.\
     * \
     * If the Project achieved their minimum budget by the minimum deadline,
     * and this deadline is defined, it may still remain in campaign to raise the optimum.
     */
    optimum?: string | null;
};

export type ProjectCalendarJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * The date at which the Project started campaigning.
     */
    release?: string | null;
    /**
     * 40 days after the date of release.\
     * \
     * The minimum budget must be raised by the end of this date.\
     * Failure to do so will move the Project out of status `in_campaign` into status `unfunded`.
     */
    minimum?: string | null;
    /**
     * 40 days after the minimum deadline. Optional.\
     * \
     * If the Project achieved their minimum budget by the minimum deadline,
     * and this deadline is defined, it may still remain in campaign to raise the optimum.
     */
    optimum?: string | null;
};

/**
 * A ProjectReward is something the Project owner wishes to give in exchange for contributions to their Project.
 */
export type ProjectReward = {
    readonly id?: number;
    /**
     * The project which gives this reward.
     */
    project: string;
    /**
     * A short, descriptive title for this reward.
     */
    title: string;
    /**
     * Information about this reward. More detailed than the title.
     */
    description: string | null;
    /**
     * The minimal monetary sum to be able to claim this reward.
     */
    money: Money;
    /**
     * Rewards might be finite, i.e: has a limited amount of existing unitsTotal.
     */
    hasUnits: boolean;
    /**
     * For finite rewards, the total amount of existing unitsTotal.\
     * Required if `hasUnits`.
     */
    unitsTotal?: number;
    /**
     * For finite rewards, the currently available amount of unitsTotal that can be claimed.
     */
    readonly unitsAvailable?: number;
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

/**
 * A ProjectReward is something the Project owner wishes to give in exchange for contributions to their Project.
 */
export type ProjectRewardJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The project which gives this reward.
     */
    project: string;
    /**
     * A short, descriptive title for this reward.
     */
    title: string;
    /**
     * Information about this reward. More detailed than the title.
     */
    description: string | null;
    /**
     * The minimal monetary sum to be able to claim this reward.
     */
    money: MoneyJsonld;
    /**
     * Rewards might be finite, i.e: has a limited amount of existing unitsTotal.
     */
    hasUnits: boolean;
    /**
     * For finite rewards, the total amount of existing unitsTotal.\
     * Required if `hasUnits`.
     */
    unitsTotal?: number;
    /**
     * For finite rewards, the currently available amount of unitsTotal that can be claimed.
     */
    readonly unitsAvailable?: number;
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

/**
 * A ProjectRewardClaim represents the will of an User who wishes to obtain one ProjectReward.
 */
export type ProjectRewardClaim = {
    readonly id?: number;
    /**
     * The User claiming the ProjectReward.
     */
    readonly owner?: string;
    /**
     * The GatewayCharge granting access to the ProjectReward.
     */
    charge: string;
    /**
     * The ProjectReward being claimed.
     */
    reward: string;
};

/**
 * A ProjectRewardClaim represents the will of an User who wishes to obtain one ProjectReward.
 */
export type ProjectRewardClaimJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The User claiming the ProjectReward.
     */
    readonly owner?: string;
    /**
     * The GatewayCharge granting access to the ProjectReward.
     */
    charge: string;
    /**
     * The ProjectReward being claimed.
     */
    reward: string;
};

export type ProjectSupport = {
    readonly id?: number;
    /**
     * The User who created the ProjectSupport record.\
     * \
     * When `anonymous` is *true* it will only be public to admins and the User.
     */
    readonly owner?: string | null;
    /**
     * The Project being targeted in the Charges.
     */
    readonly project?: string;
    /**
     * The Charges that were paid by the User.
     */
    readonly charges?: Array<string>;
    /**
     * The total monetary value of the Charges paid by the User.
     */
    money?: Money;
    /**
     * User's will to have their support to the Project be shown publicly.
     */
    anonymous: boolean;
    /**
     * A message of support from the User to the Project.
     */
    message?: string | null;
};

export type ProjectSupportJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The User who created the ProjectSupport record.\
     * \
     * When `anonymous` is *true* it will only be public to admins and the User.
     */
    readonly owner?: string | null;
    /**
     * The Project being targeted in the Charges.
     */
    readonly project?: string;
    /**
     * The Charges that were paid by the User.
     */
    readonly charges?: Array<string>;
    /**
     * The total monetary value of the Charges paid by the User.
     */
    money?: MoneyJsonld;
    /**
     * User's will to have their support to the Project be shown publicly.
     */
    anonymous: boolean;
    /**
     * A message of support from the User to the Project.
     */
    message?: string | null;
};

/**
 * A ProjectUpdate offers records of significant news during a Project's life.\
 * \
 * Updates can be for outstanding donation amounts, achievement of goals or thresholds,
 * or any other body of information that the Project owner(s) may wish to make public to the Project's audience.
 */
export type ProjectUpdate = {
    readonly id?: number;
    /**
     * The Project to which this update belongs to.
     */
    project: string;
    /**
     * Main headline for this update.
     */
    title: string;
    /**
     * Secondary headline for this update.
     */
    subtitle: string;
    /**
     * Main text body of the Project's update.
     */
    body: string;
    /**
     * Public display date for this update,
     * not necessarily related to the actual dates of resource creation or update.
     */
    date?: string;
    /**
     * URL to an image resource to be displayed as header.
     */
    cover?: string;
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

/**
 * A ProjectUpdate offers records of significant news during a Project's life.\
 * \
 * Updates can be for outstanding donation amounts, achievement of goals or thresholds,
 * or any other body of information that the Project owner(s) may wish to make public to the Project's audience.
 */
export type ProjectUpdateJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The Project to which this update belongs to.
     */
    project: string;
    /**
     * Main headline for this update.
     */
    title: string;
    /**
     * Secondary headline for this update.
     */
    subtitle: string;
    /**
     * Main text body of the Project's update.
     */
    body: string;
    /**
     * Public display date for this update,
     * not necessarily related to the actual dates of resource creation or update.
     */
    date?: string;
    /**
     * URL to an image resource to be displayed as header.
     */
    cover?: string;
    /**
     * List of the available content locales.
     */
    readonly locales?: Array<string>;
};

export type ProjectVideo = {
    src?: string | null;
    thumbnail?: string | null;
};

export type ProjectVideoJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    src?: string | null;
    thumbnail?: string | null;
};

export type Territory = {
    /**
     * ISO 3166-1 alpha-2 two-letter country code.\
     * e.g: ES (Spain).
     */
    country: string;
    /**
     * ISO 3166-2 first level subdivision code.\
     * e.g: ES-AN (Andalucía, Spain).
     */
    subLvl1?: string | null;
    /**
     * ISO 3166-2 second level subdivision code.\
     * e.g: ES-GR (Granada, Andalucía, Spain).
     */
    subLvl2?: string | null;
};

export type TerritoryJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * ISO 3166-1 alpha-2 two-letter country code.\
     * e.g: ES (Spain).
     */
    country: string;
    /**
     * ISO 3166-2 first level subdivision code.\
     * e.g: ES-AN (Andalucía, Spain).
     */
    subLvl1?: string | null;
    /**
     * ISO 3166-2 second level subdivision code.\
     * e.g: ES-GR (Granada, Andalucía, Spain).
     */
    subLvl2?: string | null;
};

/**
 * Unlike other Money recipients a Tipjar receives money with no further goal.\
 * \
 * Tips to the platform owners and other no-purpose money can target a Tipjar.
 */
export type Tipjar = {
    readonly id?: number;
    readonly accounting?: string;
    /**
     * Human readable, non white space, unique string.
     */
    name: string;
};

/**
 * Unlike other Money recipients a Tipjar receives money with no further goal.\
 * \
 * Tips to the platform owners and other no-purpose money can target a Tipjar.
 */
export type TipjarJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    readonly accounting?: string;
    /**
     * Human readable, non white space, unique string.
     */
    name: string;
};

export type Tracking = {
    /**
     * A descriptive title for the tracking number.
     */
    title?: string;
    /**
     * The tracking number given by the Gateway.
     */
    value?: string;
};

export type TrackingJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * A descriptive title for the tracking number.
     */
    title?: string;
    /**
     * The tracking number given by the Gateway.
     */
    value?: string;
};

/**
 * Users represent people who interact with the platform.
 */
export type User = {
    readonly id?: number;
    email: string;
    /**
     * A unique, non white space, byte-safe string identifier for this User.
     */
    handle: string;
    /**
     * URL to the avatar image of this User.
     */
    avatar?: string;
    /**
     * Is this User for an individual acting on their own or a group of individuals?
     */
    type?: 'individual' | 'organization';
    /**
     * A list of the roles assigned to this User. Admin scoped property.
     */
    roles?: Array<string>;
    readonly displayName?: string;
    /**
     * For `individual` User types: personal data about the User themselves.\
     * For `organization` User types: data for the organization representative or person managing the User.
     */
    readonly person?: string;
    /**
     * For `organization` User types only. Legal entity data.
     */
    readonly organization?: string | null;
    /**
     * The Accounting for this User monetary movements.
     */
    readonly accounting?: string;
    /**
     * The Projects that are owned by this User.
     */
    readonly projects?: Array<string>;
    /**
     * Has this User confirmed their email address?
     */
    readonly emailConfirmed?: boolean;
    /**
     * A flag determined by the platform for Users who are known to be active.
     */
    readonly active?: boolean;
};

/**
 * Users represent people who interact with the platform.
 */
export type UserUserSignupDto = {
    /**
     * A valid e-mail address for the new User.
     */
    email: string;
    /**
     * The auth password for the new User. Plaintext string,
     * will be hashed by the API.
     */
    password: string;
    /**
     * Is this User for an individual acting on their own or a group of individuals?
     */
    type: 'individual' | 'organization';
};

/**
 * Users represent people who interact with the platform.
 */
export type UserUserSignupDtoJsonld = {
    /**
     * A valid e-mail address for the new User.
     */
    email: string;
    /**
     * The auth password for the new User. Plaintext string,
     * will be hashed by the API.
     */
    password: string;
    /**
     * Is this User for an individual acting on their own or a group of individuals?
     */
    type: 'individual' | 'organization';
};

/**
 * Users represent people who interact with the platform.
 */
export type UserJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    email: string;
    /**
     * A unique, non white space, byte-safe string identifier for this User.
     */
    handle: string;
    /**
     * URL to the avatar image of this User.
     */
    avatar?: string;
    /**
     * Is this User for an individual acting on their own or a group of individuals?
     */
    type?: 'individual' | 'organization';
    /**
     * A list of the roles assigned to this User. Admin scoped property.
     */
    roles?: Array<string>;
    readonly displayName?: string;
    /**
     * For `individual` User types: personal data about the User themselves.\
     * For `organization` User types: data for the organization representative or person managing the User.
     */
    readonly person?: string;
    /**
     * For `organization` User types only. Legal entity data.
     */
    readonly organization?: string | null;
    /**
     * The Accounting for this User monetary movements.
     */
    readonly accounting?: string;
    /**
     * The Projects that are owned by this User.
     */
    readonly projects?: Array<string>;
    /**
     * Has this User confirmed their email address?
     */
    readonly emailConfirmed?: boolean;
    /**
     * A flag determined by the platform for Users who are known to be active.
     */
    readonly active?: boolean;
};

/**
 * UserTokens authenticate requests on behalf of the User who owns them.\
 * \
 * When a UserToken is created v4 generates a SHA-256 hash that is unique for each UserToken.
 * The value of a UserToken comes preceded by a 4-digit-length prefix based on the type of token it is.
 */
export type UserToken = {
    readonly id?: number;
    /**
     * The User token itself.
     */
    readonly token?: string;
    /**
     * The User who this token grants access as.
     */
    readonly owner?: string;
};

/**
 * UserTokens authenticate requests on behalf of the User who owns them.\
 * \
 * When a UserToken is created v4 generates a SHA-256 hash that is unique for each UserToken.
 * The value of a UserToken comes preceded by a 4-digit-length prefix based on the type of token it is.
 */
export type UserTokenUserTokenLoginDto = {
    /**
     * The identifier (email, handle) of the User to be authenticated.
     */
    identifier: string;
    /**
     * The password of the User to be authenticated.
     */
    password: string;
};

/**
 * UserTokens authenticate requests on behalf of the User who owns them.\
 * \
 * When a UserToken is created v4 generates a SHA-256 hash that is unique for each UserToken.
 * The value of a UserToken comes preceded by a 4-digit-length prefix based on the type of token it is.
 */
export type UserTokenUserTokenLoginDtoJsonld = {
    /**
     * The identifier (email, handle) of the User to be authenticated.
     */
    identifier: string;
    /**
     * The password of the User to be authenticated.
     */
    password: string;
};

/**
 * UserTokens authenticate requests on behalf of the User who owns them.\
 * \
 * When a UserToken is created v4 generates a SHA-256 hash that is unique for each UserToken.
 * The value of a UserToken comes preceded by a 4-digit-length prefix based on the type of token it is.
 */
export type UserTokenJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    readonly id?: number;
    /**
     * The User token itself.
     */
    readonly token?: string;
    /**
     * The User who this token grants access as.
     */
    readonly owner?: string;
};

/**
 * Some resources are versioned. This means v4 keeps track of the changes performed in subsets of specific properties within these resources.\
 * \
 * This allows us to keep track of the flow and the evolution of records in the platform.
 * Looking at the changes done between one version and the next one we can reconstruct how a resource was at a certain point in time.
 */
export type Version = {
    /**
     * The ID of the version record.
     */
    readonly id?: number | null;
    /**
     * The type of action that performed the recorded changes.
     */
    readonly action?: string | null;
    /**
     * The type of the recorded resource.
     */
    readonly resource?: string;
    /**
     * The ID of the recorded resource.
     */
    readonly resourceId?: number;
    /**
     * The version number for this specific resource.
     */
    readonly resourceVersion?: number | null;
    /**
     * The changed resource data, i.e the new values of the changed properties.
     */
    readonly resourceChanges?: unknown;
    /**
     * The date at which this version was created.
     */
    readonly dateCreated?: string | null;
};

/**
 * Some resources are versioned. This means v4 keeps track of the changes performed in subsets of specific properties within these resources.\
 * \
 * This allows us to keep track of the flow and the evolution of records in the platform.
 * Looking at the changes done between one version and the next one we can reconstruct how a resource was at a certain point in time.
 */
export type VersionJsonld = {
    '@context'?: string | {
        '@vocab': string;
        hydra: 'http://www.w3.org/ns/hydra/core#';
        [key: string]: unknown | string | 'http://www.w3.org/ns/hydra/core#';
    };
    readonly '@id'?: string;
    readonly '@type'?: string;
    /**
     * The ID of the version record.
     */
    readonly id?: number | null;
    /**
     * The type of action that performed the recorded changes.
     */
    readonly action?: string | null;
    /**
     * The type of the recorded resource.
     */
    readonly resource?: string;
    /**
     * The ID of the recorded resource.
     */
    readonly resourceId?: number;
    /**
     * The version number for this specific resource.
     */
    readonly resourceVersion?: number | null;
    /**
     * The changed resource data, i.e the new values of the changed properties.
     */
    readonly resourceChanges?: unknown;
    /**
     * The date at which this version was created.
     */
    readonly dateCreated?: string | null;
};

export type ApiAccountingsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/accountings';
};

export type ApiAccountingsGetCollectionResponses = {
    /**
     * Accounting collection
     */
    200: Array<Accounting>;
};

export type ApiAccountingsGetCollectionResponse = ApiAccountingsGetCollectionResponses[keyof ApiAccountingsGetCollectionResponses];

export type ApiAccountingsIdGetData = {
    body?: never;
    path: {
        /**
         * Accounting identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/accountings/{id}';
};

export type ApiAccountingsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiAccountingsIdGetError = ApiAccountingsIdGetErrors[keyof ApiAccountingsIdGetErrors];

export type ApiAccountingsIdGetResponses = {
    /**
     * Accounting resource
     */
    200: Accounting;
};

export type ApiAccountingsIdGetResponse = ApiAccountingsIdGetResponses[keyof ApiAccountingsIdGetResponses];

export type ApiAccountingsIdPatchData = {
    /**
     * The updated Accounting resource
     */
    body: Accounting;
    path: {
        /**
         * Accounting identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/accountings/{id}';
};

export type ApiAccountingsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiAccountingsIdPatchError = ApiAccountingsIdPatchErrors[keyof ApiAccountingsIdPatchErrors];

export type ApiAccountingsIdPatchResponses = {
    /**
     * Accounting resource updated
     */
    200: Accounting;
};

export type ApiAccountingsIdPatchResponse = ApiAccountingsIdPatchResponses[keyof ApiAccountingsIdPatchResponses];

export type ApiAccountingBalancePointsGetCollectionData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        /**
         * AccountingBalancePoint accounting
         */
        accounting: string;
        /**
         * AccountingBalancePoint start
         */
        start: string;
        /**
         * AccountingBalancePoint interval
         */
        interval?: string;
        /**
         * AccountingBalancePoint end
         */
        end?: string;
        /**
         * If true, the balance points are cumulative over time.
         */
        aggregate?: boolean;
    };
    url: '/v4/accounting_balance_points';
};

export type ApiAccountingBalancePointsGetCollectionResponses = {
    /**
     * AccountingBalancePoint collection
     */
    200: Array<AccountingBalancePoint>;
};

export type ApiAccountingBalancePointsGetCollectionResponse = ApiAccountingBalancePointsGetCollectionResponses[keyof ApiAccountingBalancePointsGetCollectionResponses];

export type ApiAccountingTransactionsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        origin?: string;
        'origin[]'?: Array<string>;
        target?: string;
        'target[]'?: Array<string>;
    };
    url: '/v4/accounting_transactions';
};

export type ApiAccountingTransactionsGetCollectionResponses = {
    /**
     * AccountingTransaction collection
     */
    200: Array<AccountingTransaction>;
};

export type ApiAccountingTransactionsGetCollectionResponse = ApiAccountingTransactionsGetCollectionResponses[keyof ApiAccountingTransactionsGetCollectionResponses];

export type ApiAccountingTransactionsIdGetData = {
    body?: never;
    path: {
        /**
         * AccountingTransaction identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/accounting_transactions/{id}';
};

export type ApiAccountingTransactionsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiAccountingTransactionsIdGetError = ApiAccountingTransactionsIdGetErrors[keyof ApiAccountingTransactionsIdGetErrors];

export type ApiAccountingTransactionsIdGetResponses = {
    /**
     * AccountingTransaction resource
     */
    200: AccountingTransaction;
};

export type ApiAccountingTransactionsIdGetResponse = ApiAccountingTransactionsIdGetResponses[keyof ApiAccountingTransactionsIdGetResponses];

export type ApiGatewaysGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/gateways';
};

export type ApiGatewaysGetCollectionResponses = {
    /**
     * Gateway collection
     */
    200: Array<Gateway>;
};

export type ApiGatewaysGetCollectionResponse = ApiGatewaysGetCollectionResponses[keyof ApiGatewaysGetCollectionResponses];

export type ApiGatewaysNameGetData = {
    body?: never;
    path: {
        /**
         * Gateway identifier
         */
        name: string;
    };
    query?: never;
    url: '/v4/gateways/{name}';
};

export type ApiGatewaysNameGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiGatewaysNameGetError = ApiGatewaysNameGetErrors[keyof ApiGatewaysNameGetErrors];

export type ApiGatewaysNameGetResponses = {
    /**
     * Gateway resource
     */
    200: Gateway;
};

export type ApiGatewaysNameGetResponse = ApiGatewaysNameGetResponses[keyof ApiGatewaysNameGetResponses];

export type ApiGatewayChargesGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        'checkout.gateway'?: string;
        'checkout.gateway[]'?: Array<string>;
        'checkout.trackings.value'?: string;
        'checkout.trackings.value[]'?: Array<string>;
        type?: string;
        'type[]'?: Array<string>;
        target?: string;
        'target[]'?: Array<string>;
        'money.currency'?: string;
        'money.currency[]'?: Array<string>;
        status?: string;
        'status[]'?: Array<string>;
        'money.amount[between]'?: string;
        'money.amount[gt]'?: string;
        'money.amount[gte]'?: string;
        'money.amount[lt]'?: string;
        'money.amount[lte]'?: string;
        'dateCreated[before]'?: string;
        'dateCreated[strictly_before]'?: string;
        'dateCreated[after]'?: string;
        'dateCreated[strictly_after]'?: string;
        'dateUpdated[before]'?: string;
        'dateUpdated[strictly_before]'?: string;
        'dateUpdated[after]'?: string;
        'dateUpdated[strictly_after]'?: string;
    };
    url: '/v4/gateway_charges';
};

export type ApiGatewayChargesGetCollectionResponses = {
    /**
     * GatewayCharge collection
     */
    200: Array<GatewayCharge>;
};

export type ApiGatewayChargesGetCollectionResponse = ApiGatewayChargesGetCollectionResponses[keyof ApiGatewayChargesGetCollectionResponses];

export type ApiGatewayChargesIdGetData = {
    body?: never;
    path: {
        /**
         * GatewayCharge identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/gateway_charges/{id}';
};

export type ApiGatewayChargesIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiGatewayChargesIdGetError = ApiGatewayChargesIdGetErrors[keyof ApiGatewayChargesIdGetErrors];

export type ApiGatewayChargesIdGetResponses = {
    /**
     * GatewayCharge resource
     */
    200: GatewayCharge;
};

export type ApiGatewayChargesIdGetResponse = ApiGatewayChargesIdGetResponses[keyof ApiGatewayChargesIdGetResponses];

export type ApiGatewayChargesIdPatchData = {
    /**
     * The updated GatewayCharge resource
     */
    body: GatewayChargeChargeUpdationDto;
    path: {
        /**
         * GatewayCharge identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/gateway_charges/{id}';
};

export type ApiGatewayChargesIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiGatewayChargesIdPatchError = ApiGatewayChargesIdPatchErrors[keyof ApiGatewayChargesIdPatchErrors];

export type ApiGatewayChargesIdPatchResponses = {
    /**
     * GatewayCharge resource updated
     */
    200: GatewayCharge;
};

export type ApiGatewayChargesIdPatchResponse = ApiGatewayChargesIdPatchResponses[keyof ApiGatewayChargesIdPatchResponses];

export type ApiGatewayCheckoutsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/gateway_checkouts';
};

export type ApiGatewayCheckoutsGetCollectionErrors = {
    /**
     * Forbidden
     */
    403: ErrorJsonld;
};

export type ApiGatewayCheckoutsGetCollectionError = ApiGatewayCheckoutsGetCollectionErrors[keyof ApiGatewayCheckoutsGetCollectionErrors];

export type ApiGatewayCheckoutsGetCollectionResponses = {
    /**
     * GatewayCheckout collection
     */
    200: Array<GatewayCheckout>;
};

export type ApiGatewayCheckoutsGetCollectionResponse = ApiGatewayCheckoutsGetCollectionResponses[keyof ApiGatewayCheckoutsGetCollectionResponses];

export type ApiGatewayCheckoutsPostData = {
    /**
     * The new GatewayCheckout resource
     */
    body: GatewayCheckout;
    path?: never;
    query?: never;
    url: '/v4/gateway_checkouts';
};

export type ApiGatewayCheckoutsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiGatewayCheckoutsPostError = ApiGatewayCheckoutsPostErrors[keyof ApiGatewayCheckoutsPostErrors];

export type ApiGatewayCheckoutsPostResponses = {
    /**
     * GatewayCheckout resource created
     */
    201: GatewayCheckout;
};

export type ApiGatewayCheckoutsPostResponse = ApiGatewayCheckoutsPostResponses[keyof ApiGatewayCheckoutsPostResponses];

export type ApiGatewayCheckoutsIdGetData = {
    body?: never;
    path: {
        /**
         * GatewayCheckout identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/gateway_checkouts/{id}';
};

export type ApiGatewayCheckoutsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiGatewayCheckoutsIdGetError = ApiGatewayCheckoutsIdGetErrors[keyof ApiGatewayCheckoutsIdGetErrors];

export type ApiGatewayCheckoutsIdGetResponses = {
    /**
     * GatewayCheckout resource
     */
    200: GatewayCheckout;
};

export type ApiGatewayCheckoutsIdGetResponse = ApiGatewayCheckoutsIdGetResponses[keyof ApiGatewayCheckoutsIdGetResponses];

export type ApiGatewayCheckoutsIdPatchData = {
    /**
     * The updated GatewayCheckout resource
     */
    body: GatewayCheckoutCheckoutUpdationDto;
    path: {
        /**
         * GatewayCheckout identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/gateway_checkouts/{id}';
};

export type ApiGatewayCheckoutsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiGatewayCheckoutsIdPatchError = ApiGatewayCheckoutsIdPatchErrors[keyof ApiGatewayCheckoutsIdPatchErrors];

export type ApiGatewayCheckoutsIdPatchResponses = {
    /**
     * GatewayCheckout resource updated
     */
    200: GatewayCheckout;
};

export type ApiGatewayCheckoutsIdPatchResponse = ApiGatewayCheckoutsIdPatchResponses[keyof ApiGatewayCheckoutsIdPatchResponses];

export type ApiMatchCallsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/match_calls';
};

export type ApiMatchCallsGetCollectionResponses = {
    /**
     * MatchCall collection
     */
    200: Array<MatchCall>;
};

export type ApiMatchCallsGetCollectionResponse = ApiMatchCallsGetCollectionResponses[keyof ApiMatchCallsGetCollectionResponses];

export type ApiMatchCallsPostData = {
    /**
     * The new MatchCall resource
     */
    body: MatchCall;
    path?: never;
    query?: never;
    url: '/v4/match_calls';
};

export type ApiMatchCallsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiMatchCallsPostError = ApiMatchCallsPostErrors[keyof ApiMatchCallsPostErrors];

export type ApiMatchCallsPostResponses = {
    /**
     * MatchCall resource created
     */
    201: MatchCall;
};

export type ApiMatchCallsPostResponse = ApiMatchCallsPostResponses[keyof ApiMatchCallsPostResponses];

export type ApiMatchCallsIdDeleteData = {
    body?: never;
    path: {
        /**
         * MatchCall identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_calls/{id}';
};

export type ApiMatchCallsIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiMatchCallsIdDeleteError = ApiMatchCallsIdDeleteErrors[keyof ApiMatchCallsIdDeleteErrors];

export type ApiMatchCallsIdDeleteResponses = {
    /**
     * MatchCall resource deleted
     */
    204: void;
};

export type ApiMatchCallsIdDeleteResponse = ApiMatchCallsIdDeleteResponses[keyof ApiMatchCallsIdDeleteResponses];

export type ApiMatchCallsIdGetData = {
    body?: never;
    path: {
        /**
         * MatchCall identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_calls/{id}';
};

export type ApiMatchCallsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiMatchCallsIdGetError = ApiMatchCallsIdGetErrors[keyof ApiMatchCallsIdGetErrors];

export type ApiMatchCallsIdGetResponses = {
    /**
     * MatchCall resource
     */
    200: MatchCall;
};

export type ApiMatchCallsIdGetResponse = ApiMatchCallsIdGetResponses[keyof ApiMatchCallsIdGetResponses];

export type ApiMatchCallsIdPatchData = {
    /**
     * The updated MatchCall resource
     */
    body: MatchCall;
    path: {
        /**
         * MatchCall identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_calls/{id}';
};

export type ApiMatchCallsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiMatchCallsIdPatchError = ApiMatchCallsIdPatchErrors[keyof ApiMatchCallsIdPatchErrors];

export type ApiMatchCallsIdPatchResponses = {
    /**
     * MatchCall resource updated
     */
    200: MatchCall;
};

export type ApiMatchCallsIdPatchResponse = ApiMatchCallsIdPatchResponses[keyof ApiMatchCallsIdPatchResponses];

export type ApiMatchCallSubmissionsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/match_call_submissions';
};

export type ApiMatchCallSubmissionsGetCollectionResponses = {
    /**
     * MatchCallSubmission collection
     */
    200: Array<MatchCallSubmission>;
};

export type ApiMatchCallSubmissionsGetCollectionResponse = ApiMatchCallSubmissionsGetCollectionResponses[keyof ApiMatchCallSubmissionsGetCollectionResponses];

export type ApiMatchCallSubmissionsPostData = {
    /**
     * The new MatchCallSubmission resource
     */
    body: MatchCallSubmissionMatchCallSubmissionCreationDto;
    path?: never;
    query?: never;
    url: '/v4/match_call_submissions';
};

export type ApiMatchCallSubmissionsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiMatchCallSubmissionsPostError = ApiMatchCallSubmissionsPostErrors[keyof ApiMatchCallSubmissionsPostErrors];

export type ApiMatchCallSubmissionsPostResponses = {
    /**
     * MatchCallSubmission resource created
     */
    201: MatchCallSubmission;
};

export type ApiMatchCallSubmissionsPostResponse = ApiMatchCallSubmissionsPostResponses[keyof ApiMatchCallSubmissionsPostResponses];

export type ApiMatchCallSubmissionsIdGetData = {
    body?: never;
    path: {
        /**
         * MatchCallSubmission identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_call_submissions/{id}';
};

export type ApiMatchCallSubmissionsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiMatchCallSubmissionsIdGetError = ApiMatchCallSubmissionsIdGetErrors[keyof ApiMatchCallSubmissionsIdGetErrors];

export type ApiMatchCallSubmissionsIdGetResponses = {
    /**
     * MatchCallSubmission resource
     */
    200: MatchCallSubmission;
};

export type ApiMatchCallSubmissionsIdGetResponse = ApiMatchCallSubmissionsIdGetResponses[keyof ApiMatchCallSubmissionsIdGetResponses];

export type ApiMatchCallSubmissionsIdPatchData = {
    /**
     * The updated MatchCallSubmission resource
     */
    body: MatchCallSubmission;
    path: {
        /**
         * MatchCallSubmission identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_call_submissions/{id}';
};

export type ApiMatchCallSubmissionsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiMatchCallSubmissionsIdPatchError = ApiMatchCallSubmissionsIdPatchErrors[keyof ApiMatchCallSubmissionsIdPatchErrors];

export type ApiMatchCallSubmissionsIdPatchResponses = {
    /**
     * MatchCallSubmission resource updated
     */
    200: MatchCallSubmission;
};

export type ApiMatchCallSubmissionsIdPatchResponse = ApiMatchCallSubmissionsIdPatchResponses[keyof ApiMatchCallSubmissionsIdPatchResponses];

export type ApiMatchFormulasGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/match_formulas';
};

export type ApiMatchFormulasGetCollectionResponses = {
    /**
     * MatchFormula collection
     */
    200: Array<MatchFormula>;
};

export type ApiMatchFormulasGetCollectionResponse = ApiMatchFormulasGetCollectionResponses[keyof ApiMatchFormulasGetCollectionResponses];

export type ApiMatchFormulasNameGetData = {
    body?: never;
    path: {
        /**
         * MatchFormula identifier
         */
        name: string;
    };
    query?: never;
    url: '/v4/match_formulas/{name}';
};

export type ApiMatchFormulasNameGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiMatchFormulasNameGetError = ApiMatchFormulasNameGetErrors[keyof ApiMatchFormulasNameGetErrors];

export type ApiMatchFormulasNameGetResponses = {
    /**
     * MatchFormula resource
     */
    200: MatchFormula;
};

export type ApiMatchFormulasNameGetResponse = ApiMatchFormulasNameGetResponses[keyof ApiMatchFormulasNameGetResponses];

export type ApiMatchRulesGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/match_rules';
};

export type ApiMatchRulesGetCollectionResponses = {
    /**
     * MatchRule collection
     */
    200: Array<MatchRule>;
};

export type ApiMatchRulesGetCollectionResponse = ApiMatchRulesGetCollectionResponses[keyof ApiMatchRulesGetCollectionResponses];

export type ApiMatchRulesNameGetData = {
    body?: never;
    path: {
        /**
         * MatchRule identifier
         */
        name: string;
    };
    query?: never;
    url: '/v4/match_rules/{name}';
};

export type ApiMatchRulesNameGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiMatchRulesNameGetError = ApiMatchRulesNameGetErrors[keyof ApiMatchRulesNameGetErrors];

export type ApiMatchRulesNameGetResponses = {
    /**
     * MatchRule resource
     */
    200: MatchRule;
};

export type ApiMatchRulesNameGetResponse = ApiMatchRulesNameGetResponses[keyof ApiMatchRulesNameGetResponses];

export type ApiMatchCallIdstrategyGetData = {
    body?: never;
    path: {
        /**
         * MatchCall identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_call/{id}/strategy';
};

export type ApiMatchCallIdstrategyGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiMatchCallIdstrategyGetError = ApiMatchCallIdstrategyGetErrors[keyof ApiMatchCallIdstrategyGetErrors];

export type ApiMatchCallIdstrategyGetResponses = {
    /**
     * MatchStrategy resource
     */
    200: MatchStrategy;
};

export type ApiMatchCallIdstrategyGetResponse = ApiMatchCallIdstrategyGetResponses[keyof ApiMatchCallIdstrategyGetResponses];

export type ApiMatchCallIdstrategyPatchData = {
    /**
     * The updated MatchStrategy resource
     */
    body: MatchStrategy;
    path: {
        /**
         * MatchCall identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/match_call/{id}/strategy';
};

export type ApiMatchCallIdstrategyPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiMatchCallIdstrategyPatchError = ApiMatchCallIdstrategyPatchErrors[keyof ApiMatchCallIdstrategyPatchErrors];

export type ApiMatchCallIdstrategyPatchResponses = {
    /**
     * MatchStrategy resource updated
     */
    200: MatchStrategy;
};

export type ApiMatchCallIdstrategyPatchResponse = ApiMatchCallIdstrategyPatchResponses[keyof ApiMatchCallIdstrategyPatchResponses];

export type ApiUsersIdorganizationGetData = {
    body?: never;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}/organization';
};

export type ApiUsersIdorganizationGetErrors = {
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiUsersIdorganizationGetError = ApiUsersIdorganizationGetErrors[keyof ApiUsersIdorganizationGetErrors];

export type ApiUsersIdorganizationGetResponses = {
    /**
     * Organization resource
     */
    200: Organization;
};

export type ApiUsersIdorganizationGetResponse = ApiUsersIdorganizationGetResponses[keyof ApiUsersIdorganizationGetResponses];

export type ApiUsersIdorganizationPatchData = {
    /**
     * The updated Organization resource
     */
    body: Organization;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}/organization';
};

export type ApiUsersIdorganizationPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiUsersIdorganizationPatchError = ApiUsersIdorganizationPatchErrors[keyof ApiUsersIdorganizationPatchErrors];

export type ApiUsersIdorganizationPatchResponses = {
    /**
     * Organization resource updated
     */
    200: Organization;
};

export type ApiUsersIdorganizationPatchResponse = ApiUsersIdorganizationPatchResponses[keyof ApiUsersIdorganizationPatchResponses];

export type ApiUsersIdpersonGetData = {
    body?: never;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}/person';
};

export type ApiUsersIdpersonGetErrors = {
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiUsersIdpersonGetError = ApiUsersIdpersonGetErrors[keyof ApiUsersIdpersonGetErrors];

export type ApiUsersIdpersonGetResponses = {
    /**
     * Person resource
     */
    200: Person;
};

export type ApiUsersIdpersonGetResponse = ApiUsersIdpersonGetResponses[keyof ApiUsersIdpersonGetResponses];

export type ApiUsersIdpersonPatchData = {
    /**
     * The updated Person resource
     */
    body: Person;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}/person';
};

export type ApiUsersIdpersonPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiUsersIdpersonPatchError = ApiUsersIdpersonPatchErrors[keyof ApiUsersIdpersonPatchErrors];

export type ApiUsersIdpersonPatchResponses = {
    /**
     * Person resource updated
     */
    200: Person;
};

export type ApiUsersIdpersonPatchResponse = ApiUsersIdpersonPatchResponses[keyof ApiUsersIdpersonPatchResponses];

export type ApiProjectsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        slug?: string;
        'slug[]'?: Array<string>;
        title?: string;
        subtitle?: string;
        category?: string;
        'category[]'?: Array<string>;
        description?: string;
        status?: string;
        'status[]'?: Array<string>;
    };
    url: '/v4/projects';
};

export type ApiProjectsGetCollectionResponses = {
    /**
     * Project collection
     */
    200: Array<Project>;
};

export type ApiProjectsGetCollectionResponse = ApiProjectsGetCollectionResponses[keyof ApiProjectsGetCollectionResponses];

export type ApiProjectsPostData = {
    /**
     * The new Project resource
     */
    body: ProjectProjectCreationDto;
    path?: never;
    query?: never;
    url: '/v4/projects';
};

export type ApiProjectsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectsPostError = ApiProjectsPostErrors[keyof ApiProjectsPostErrors];

export type ApiProjectsPostResponses = {
    /**
     * Project resource created
     */
    201: Project;
};

export type ApiProjectsPostResponse = ApiProjectsPostResponses[keyof ApiProjectsPostResponses];

export type ApiProjectsIdOrSlugGetData = {
    body?: never;
    path: {
        /**
         * Project identifier or slug
         */
        idOrSlug: string;
    };
    query?: never;
    url: '/v4/projects/{idOrSlug}';
};

export type ApiProjectsIdOrSlugGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectsIdOrSlugGetError = ApiProjectsIdOrSlugGetErrors[keyof ApiProjectsIdOrSlugGetErrors];

export type ApiProjectsIdOrSlugGetResponses = {
    /**
     * Project resource
     */
    200: Project;
};

export type ApiProjectsIdOrSlugGetResponse = ApiProjectsIdOrSlugGetResponses[keyof ApiProjectsIdOrSlugGetResponses];

export type ApiProjectsIdDeleteData = {
    body?: never;
    path: {
        /**
         * Project identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/projects/{id}';
};

export type ApiProjectsIdDeleteErrors = {
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectsIdDeleteError = ApiProjectsIdDeleteErrors[keyof ApiProjectsIdDeleteErrors];

export type ApiProjectsIdDeleteResponses = {
    /**
     * Project resource deleted
     */
    204: void;
};

export type ApiProjectsIdDeleteResponse = ApiProjectsIdDeleteResponses[keyof ApiProjectsIdDeleteResponses];

export type ApiProjectsIdPatchData = {
    /**
     * The updated Project resource
     */
    body: ProjectProjectUpdationDto;
    path: {
        /**
         * Project identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/projects/{id}';
};

export type ApiProjectsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectsIdPatchError = ApiProjectsIdPatchErrors[keyof ApiProjectsIdPatchErrors];

export type ApiProjectsIdPatchResponses = {
    /**
     * Project resource updated
     */
    200: Project;
};

export type ApiProjectsIdPatchResponse = ApiProjectsIdPatchResponses[keyof ApiProjectsIdPatchResponses];

export type ApiProjectBudgetItemsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        project?: string;
        'project[]'?: Array<string>;
    };
    url: '/v4/project_budget_items';
};

export type ApiProjectBudgetItemsGetCollectionResponses = {
    /**
     * ProjectBudgetItem collection
     */
    200: Array<ProjectBudgetItem>;
};

export type ApiProjectBudgetItemsGetCollectionResponse = ApiProjectBudgetItemsGetCollectionResponses[keyof ApiProjectBudgetItemsGetCollectionResponses];

export type ApiProjectBudgetItemsPostData = {
    /**
     * The new ProjectBudgetItem resource
     */
    body: ProjectBudgetItem;
    path?: never;
    query?: never;
    url: '/v4/project_budget_items';
};

export type ApiProjectBudgetItemsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectBudgetItemsPostError = ApiProjectBudgetItemsPostErrors[keyof ApiProjectBudgetItemsPostErrors];

export type ApiProjectBudgetItemsPostResponses = {
    /**
     * ProjectBudgetItem resource created
     */
    201: ProjectBudgetItem;
};

export type ApiProjectBudgetItemsPostResponse = ApiProjectBudgetItemsPostResponses[keyof ApiProjectBudgetItemsPostResponses];

export type ApiProjectBudgetItemsIdDeleteData = {
    body?: never;
    path: {
        /**
         * ProjectBudgetItem identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_budget_items/{id}';
};

export type ApiProjectBudgetItemsIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectBudgetItemsIdDeleteError = ApiProjectBudgetItemsIdDeleteErrors[keyof ApiProjectBudgetItemsIdDeleteErrors];

export type ApiProjectBudgetItemsIdDeleteResponses = {
    /**
     * ProjectBudgetItem resource deleted
     */
    204: void;
};

export type ApiProjectBudgetItemsIdDeleteResponse = ApiProjectBudgetItemsIdDeleteResponses[keyof ApiProjectBudgetItemsIdDeleteResponses];

export type ApiProjectBudgetItemsIdGetData = {
    body?: never;
    path: {
        /**
         * ProjectBudgetItem identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_budget_items/{id}';
};

export type ApiProjectBudgetItemsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectBudgetItemsIdGetError = ApiProjectBudgetItemsIdGetErrors[keyof ApiProjectBudgetItemsIdGetErrors];

export type ApiProjectBudgetItemsIdGetResponses = {
    /**
     * ProjectBudgetItem resource
     */
    200: ProjectBudgetItem;
};

export type ApiProjectBudgetItemsIdGetResponse = ApiProjectBudgetItemsIdGetResponses[keyof ApiProjectBudgetItemsIdGetResponses];

export type ApiProjectBudgetItemsIdPatchData = {
    /**
     * The updated ProjectBudgetItem resource
     */
    body: ProjectBudgetItem;
    path: {
        /**
         * ProjectBudgetItem identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_budget_items/{id}';
};

export type ApiProjectBudgetItemsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectBudgetItemsIdPatchError = ApiProjectBudgetItemsIdPatchErrors[keyof ApiProjectBudgetItemsIdPatchErrors];

export type ApiProjectBudgetItemsIdPatchResponses = {
    /**
     * ProjectBudgetItem resource updated
     */
    200: ProjectBudgetItem;
};

export type ApiProjectBudgetItemsIdPatchResponse = ApiProjectBudgetItemsIdPatchResponses[keyof ApiProjectBudgetItemsIdPatchResponses];

export type ApiProjectRewardsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        project?: string;
        'project[]'?: Array<string>;
    };
    url: '/v4/project_rewards';
};

export type ApiProjectRewardsGetCollectionResponses = {
    /**
     * ProjectReward collection
     */
    200: Array<ProjectReward>;
};

export type ApiProjectRewardsGetCollectionResponse = ApiProjectRewardsGetCollectionResponses[keyof ApiProjectRewardsGetCollectionResponses];

export type ApiProjectRewardsPostData = {
    /**
     * The new ProjectReward resource
     */
    body: ProjectReward;
    path?: never;
    query?: never;
    url: '/v4/project_rewards';
};

export type ApiProjectRewardsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectRewardsPostError = ApiProjectRewardsPostErrors[keyof ApiProjectRewardsPostErrors];

export type ApiProjectRewardsPostResponses = {
    /**
     * ProjectReward resource created
     */
    201: ProjectReward;
};

export type ApiProjectRewardsPostResponse = ApiProjectRewardsPostResponses[keyof ApiProjectRewardsPostResponses];

export type ApiProjectRewardsIdDeleteData = {
    body?: never;
    path: {
        /**
         * ProjectReward identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_rewards/{id}';
};

export type ApiProjectRewardsIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectRewardsIdDeleteError = ApiProjectRewardsIdDeleteErrors[keyof ApiProjectRewardsIdDeleteErrors];

export type ApiProjectRewardsIdDeleteResponses = {
    /**
     * ProjectReward resource deleted
     */
    204: void;
};

export type ApiProjectRewardsIdDeleteResponse = ApiProjectRewardsIdDeleteResponses[keyof ApiProjectRewardsIdDeleteResponses];

export type ApiProjectRewardsIdGetData = {
    body?: never;
    path: {
        /**
         * ProjectReward identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_rewards/{id}';
};

export type ApiProjectRewardsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectRewardsIdGetError = ApiProjectRewardsIdGetErrors[keyof ApiProjectRewardsIdGetErrors];

export type ApiProjectRewardsIdGetResponses = {
    /**
     * ProjectReward resource
     */
    200: ProjectReward;
};

export type ApiProjectRewardsIdGetResponse = ApiProjectRewardsIdGetResponses[keyof ApiProjectRewardsIdGetResponses];

export type ApiProjectRewardsIdPatchData = {
    /**
     * The updated ProjectReward resource
     */
    body: ProjectReward;
    path: {
        /**
         * ProjectReward identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_rewards/{id}';
};

export type ApiProjectRewardsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectRewardsIdPatchError = ApiProjectRewardsIdPatchErrors[keyof ApiProjectRewardsIdPatchErrors];

export type ApiProjectRewardsIdPatchResponses = {
    /**
     * ProjectReward resource updated
     */
    200: ProjectReward;
};

export type ApiProjectRewardsIdPatchResponse = ApiProjectRewardsIdPatchResponses[keyof ApiProjectRewardsIdPatchResponses];

export type ApiProjectRewardClaimsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
    };
    url: '/v4/project_reward_claims';
};

export type ApiProjectRewardClaimsGetCollectionResponses = {
    /**
     * ProjectRewardClaim collection
     */
    200: Array<ProjectRewardClaim>;
};

export type ApiProjectRewardClaimsGetCollectionResponse = ApiProjectRewardClaimsGetCollectionResponses[keyof ApiProjectRewardClaimsGetCollectionResponses];

export type ApiProjectRewardClaimsPostData = {
    /**
     * The new ProjectRewardClaim resource
     */
    body: ProjectRewardClaim;
    path?: never;
    query?: never;
    url: '/v4/project_reward_claims';
};

export type ApiProjectRewardClaimsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectRewardClaimsPostError = ApiProjectRewardClaimsPostErrors[keyof ApiProjectRewardClaimsPostErrors];

export type ApiProjectRewardClaimsPostResponses = {
    /**
     * ProjectRewardClaim resource created
     */
    201: ProjectRewardClaim;
};

export type ApiProjectRewardClaimsPostResponse = ApiProjectRewardClaimsPostResponses[keyof ApiProjectRewardClaimsPostResponses];

export type ApiProjectRewardClaimsIdDeleteData = {
    body?: never;
    path: {
        /**
         * ProjectRewardClaim identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_reward_claims/{id}';
};

export type ApiProjectRewardClaimsIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectRewardClaimsIdDeleteError = ApiProjectRewardClaimsIdDeleteErrors[keyof ApiProjectRewardClaimsIdDeleteErrors];

export type ApiProjectRewardClaimsIdDeleteResponses = {
    /**
     * ProjectRewardClaim resource deleted
     */
    204: void;
};

export type ApiProjectRewardClaimsIdDeleteResponse = ApiProjectRewardClaimsIdDeleteResponses[keyof ApiProjectRewardClaimsIdDeleteResponses];

export type ApiProjectRewardClaimsIdGetData = {
    body?: never;
    path: {
        /**
         * ProjectRewardClaim identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_reward_claims/{id}';
};

export type ApiProjectRewardClaimsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectRewardClaimsIdGetError = ApiProjectRewardClaimsIdGetErrors[keyof ApiProjectRewardClaimsIdGetErrors];

export type ApiProjectRewardClaimsIdGetResponses = {
    /**
     * ProjectRewardClaim resource
     */
    200: ProjectRewardClaim;
};

export type ApiProjectRewardClaimsIdGetResponse = ApiProjectRewardClaimsIdGetResponses[keyof ApiProjectRewardClaimsIdGetResponses];

export type ApiProjectRewardClaimsIdPatchData = {
    /**
     * The updated ProjectRewardClaim resource
     */
    body: ProjectRewardClaim;
    path: {
        /**
         * ProjectRewardClaim identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_reward_claims/{id}';
};

export type ApiProjectRewardClaimsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectRewardClaimsIdPatchError = ApiProjectRewardClaimsIdPatchErrors[keyof ApiProjectRewardClaimsIdPatchErrors];

export type ApiProjectRewardClaimsIdPatchResponses = {
    /**
     * ProjectRewardClaim resource updated
     */
    200: ProjectRewardClaim;
};

export type ApiProjectRewardClaimsIdPatchResponse = ApiProjectRewardClaimsIdPatchResponses[keyof ApiProjectRewardClaimsIdPatchResponses];

export type ApiProjectSupportsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        owner?: string;
        'owner[]'?: Array<string>;
        project?: string;
        'project[]'?: Array<string>;
    };
    url: '/v4/project_supports';
};

export type ApiProjectSupportsGetCollectionResponses = {
    /**
     * ProjectSupport collection
     */
    200: Array<ProjectSupport>;
};

export type ApiProjectSupportsGetCollectionResponse = ApiProjectSupportsGetCollectionResponses[keyof ApiProjectSupportsGetCollectionResponses];

export type ApiProjectSupportsIdGetData = {
    body?: never;
    path: {
        /**
         * ProjectSupport identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_supports/{id}';
};

export type ApiProjectSupportsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectSupportsIdGetError = ApiProjectSupportsIdGetErrors[keyof ApiProjectSupportsIdGetErrors];

export type ApiProjectSupportsIdGetResponses = {
    /**
     * ProjectSupport resource
     */
    200: ProjectSupport;
};

export type ApiProjectSupportsIdGetResponse = ApiProjectSupportsIdGetResponses[keyof ApiProjectSupportsIdGetResponses];

export type ApiProjectSupportsIdPatchData = {
    /**
     * The updated ProjectSupport resource
     */
    body: ProjectSupport;
    path: {
        /**
         * ProjectSupport identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_supports/{id}';
};

export type ApiProjectSupportsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectSupportsIdPatchError = ApiProjectSupportsIdPatchErrors[keyof ApiProjectSupportsIdPatchErrors];

export type ApiProjectSupportsIdPatchResponses = {
    /**
     * ProjectSupport resource updated
     */
    200: ProjectSupport;
};

export type ApiProjectSupportsIdPatchResponse = ApiProjectSupportsIdPatchResponses[keyof ApiProjectSupportsIdPatchResponses];

export type ApiProjectUpdatesGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        project?: string;
        'project[]'?: Array<string>;
        'order[date]'?: 'asc' | 'desc';
    };
    url: '/v4/project_updates';
};

export type ApiProjectUpdatesGetCollectionResponses = {
    /**
     * ProjectUpdate collection
     */
    200: Array<ProjectUpdate>;
};

export type ApiProjectUpdatesGetCollectionResponse = ApiProjectUpdatesGetCollectionResponses[keyof ApiProjectUpdatesGetCollectionResponses];

export type ApiProjectUpdatesPostData = {
    /**
     * The new ProjectUpdate resource
     */
    body: ProjectUpdate;
    path?: never;
    query?: never;
    url: '/v4/project_updates';
};

export type ApiProjectUpdatesPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectUpdatesPostError = ApiProjectUpdatesPostErrors[keyof ApiProjectUpdatesPostErrors];

export type ApiProjectUpdatesPostResponses = {
    /**
     * ProjectUpdate resource created
     */
    201: ProjectUpdate;
};

export type ApiProjectUpdatesPostResponse = ApiProjectUpdatesPostResponses[keyof ApiProjectUpdatesPostResponses];

export type ApiProjectUpdatesIdDeleteData = {
    body?: never;
    path: {
        /**
         * ProjectUpdate identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_updates/{id}';
};

export type ApiProjectUpdatesIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectUpdatesIdDeleteError = ApiProjectUpdatesIdDeleteErrors[keyof ApiProjectUpdatesIdDeleteErrors];

export type ApiProjectUpdatesIdDeleteResponses = {
    /**
     * ProjectUpdate resource deleted
     */
    204: void;
};

export type ApiProjectUpdatesIdDeleteResponse = ApiProjectUpdatesIdDeleteResponses[keyof ApiProjectUpdatesIdDeleteResponses];

export type ApiProjectUpdatesIdGetData = {
    body?: never;
    path: {
        /**
         * ProjectUpdate identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_updates/{id}';
};

export type ApiProjectUpdatesIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiProjectUpdatesIdGetError = ApiProjectUpdatesIdGetErrors[keyof ApiProjectUpdatesIdGetErrors];

export type ApiProjectUpdatesIdGetResponses = {
    /**
     * ProjectUpdate resource
     */
    200: ProjectUpdate;
};

export type ApiProjectUpdatesIdGetResponse = ApiProjectUpdatesIdGetResponses[keyof ApiProjectUpdatesIdGetResponses];

export type ApiProjectUpdatesIdPatchData = {
    /**
     * The updated ProjectUpdate resource
     */
    body: ProjectUpdate;
    path: {
        /**
         * ProjectUpdate identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/project_updates/{id}';
};

export type ApiProjectUpdatesIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiProjectUpdatesIdPatchError = ApiProjectUpdatesIdPatchErrors[keyof ApiProjectUpdatesIdPatchErrors];

export type ApiProjectUpdatesIdPatchResponses = {
    /**
     * ProjectUpdate resource updated
     */
    200: ProjectUpdate;
};

export type ApiProjectUpdatesIdPatchResponse = ApiProjectUpdatesIdPatchResponses[keyof ApiProjectUpdatesIdPatchResponses];

export type ApiTipjarsGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        name?: string;
    };
    url: '/v4/tipjars';
};

export type ApiTipjarsGetCollectionResponses = {
    /**
     * Tipjar collection
     */
    200: Array<Tipjar>;
};

export type ApiTipjarsGetCollectionResponse = ApiTipjarsGetCollectionResponses[keyof ApiTipjarsGetCollectionResponses];

export type ApiTipjarsPostData = {
    /**
     * The new Tipjar resource
     */
    body: Tipjar;
    path?: never;
    query?: never;
    url: '/v4/tipjars';
};

export type ApiTipjarsPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiTipjarsPostError = ApiTipjarsPostErrors[keyof ApiTipjarsPostErrors];

export type ApiTipjarsPostResponses = {
    /**
     * Tipjar resource created
     */
    201: Tipjar;
};

export type ApiTipjarsPostResponse = ApiTipjarsPostResponses[keyof ApiTipjarsPostResponses];

export type ApiTipjarsIdDeleteData = {
    body?: never;
    path: {
        /**
         * Tipjar identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/tipjars/{id}';
};

export type ApiTipjarsIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiTipjarsIdDeleteError = ApiTipjarsIdDeleteErrors[keyof ApiTipjarsIdDeleteErrors];

export type ApiTipjarsIdDeleteResponses = {
    /**
     * Tipjar resource deleted
     */
    204: void;
};

export type ApiTipjarsIdDeleteResponse = ApiTipjarsIdDeleteResponses[keyof ApiTipjarsIdDeleteResponses];

export type ApiTipjarsIdGetData = {
    body?: never;
    path: {
        /**
         * Tipjar identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/tipjars/{id}';
};

export type ApiTipjarsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiTipjarsIdGetError = ApiTipjarsIdGetErrors[keyof ApiTipjarsIdGetErrors];

export type ApiTipjarsIdGetResponses = {
    /**
     * Tipjar resource
     */
    200: Tipjar;
};

export type ApiTipjarsIdGetResponse = ApiTipjarsIdGetResponses[keyof ApiTipjarsIdGetResponses];

export type ApiTipjarsIdPatchData = {
    /**
     * The updated Tipjar resource
     */
    body: Tipjar;
    path: {
        /**
         * Tipjar identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/tipjars/{id}';
};

export type ApiTipjarsIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiTipjarsIdPatchError = ApiTipjarsIdPatchErrors[keyof ApiTipjarsIdPatchErrors];

export type ApiTipjarsIdPatchResponses = {
    /**
     * Tipjar resource updated
     */
    200: Tipjar;
};

export type ApiTipjarsIdPatchResponse = ApiTipjarsIdPatchResponses[keyof ApiTipjarsIdPatchResponses];

export type ApiUsersGetCollectionData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        /**
         * Query Users by email or handle. Fuzzy.
         */
        query?: string;
        handle?: string;
    };
    url: '/v4/users';
};

export type ApiUsersGetCollectionResponses = {
    /**
     * User collection
     */
    200: Array<User>;
};

export type ApiUsersGetCollectionResponse = ApiUsersGetCollectionResponses[keyof ApiUsersGetCollectionResponses];

export type ApiUsersPostData = {
    /**
     * The new User resource
     */
    body: UserUserSignupDto;
    path?: never;
    query?: never;
    url: '/v4/users';
};

export type ApiUsersPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiUsersPostError = ApiUsersPostErrors[keyof ApiUsersPostErrors];

export type ApiUsersPostResponses = {
    /**
     * User resource created
     */
    201: User;
};

export type ApiUsersPostResponse = ApiUsersPostResponses[keyof ApiUsersPostResponses];

export type ApiUsersIdDeleteData = {
    body?: never;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}';
};

export type ApiUsersIdDeleteErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiUsersIdDeleteError = ApiUsersIdDeleteErrors[keyof ApiUsersIdDeleteErrors];

export type ApiUsersIdDeleteResponses = {
    /**
     * User resource deleted
     */
    204: void;
};

export type ApiUsersIdDeleteResponse = ApiUsersIdDeleteResponses[keyof ApiUsersIdDeleteResponses];

export type ApiUsersIdGetData = {
    body?: never;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}';
};

export type ApiUsersIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiUsersIdGetError = ApiUsersIdGetErrors[keyof ApiUsersIdGetErrors];

export type ApiUsersIdGetResponses = {
    /**
     * User resource
     */
    200: User;
};

export type ApiUsersIdGetResponse = ApiUsersIdGetResponses[keyof ApiUsersIdGetResponses];

export type ApiUsersIdPatchData = {
    /**
     * The updated User resource
     */
    body: User;
    path: {
        /**
         * User identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/users/{id}';
};

export type ApiUsersIdPatchErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiUsersIdPatchError = ApiUsersIdPatchErrors[keyof ApiUsersIdPatchErrors];

export type ApiUsersIdPatchResponses = {
    /**
     * User resource updated
     */
    200: User;
};

export type ApiUsersIdPatchResponse = ApiUsersIdPatchResponses[keyof ApiUsersIdPatchResponses];

export type ApiUserTokensPostData = {
    /**
     * The new UserToken resource
     */
    body: UserTokenUserTokenLoginDto;
    path?: never;
    query?: never;
    url: '/v4/user_tokens';
};

export type ApiUserTokensPostErrors = {
    /**
     * Invalid input
     */
    400: ErrorJsonld;
    /**
     * An error occurred
     */
    422: ConstraintViolationJsonldJsonld;
};

export type ApiUserTokensPostError = ApiUserTokensPostErrors[keyof ApiUserTokensPostErrors];

export type ApiUserTokensPostResponses = {
    /**
     * UserToken resource created
     */
    201: UserToken;
};

export type ApiUserTokensPostResponse = ApiUserTokensPostResponses[keyof ApiUserTokensPostResponses];

export type ApiUserTokensIdDeleteData = {
    body?: never;
    path: {
        /**
         * UserToken identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/user_tokens/{id}';
};

export type ApiUserTokensIdDeleteErrors = {
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiUserTokensIdDeleteError = ApiUserTokensIdDeleteErrors[keyof ApiUserTokensIdDeleteErrors];

export type ApiUserTokensIdDeleteResponses = {
    /**
     * UserToken resource deleted
     */
    204: void;
};

export type ApiUserTokensIdDeleteResponse = ApiUserTokensIdDeleteResponses[keyof ApiUserTokensIdDeleteResponses];

export type ApiUserTokensIdGetData = {
    body?: never;
    path: {
        /**
         * UserToken identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/user_tokens/{id}';
};

export type ApiUserTokensIdGetErrors = {
    /**
     * Forbidden
     */
    403: ErrorJsonld;
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiUserTokensIdGetError = ApiUserTokensIdGetErrors[keyof ApiUserTokensIdGetErrors];

export type ApiUserTokensIdGetResponses = {
    /**
     * UserToken resource
     */
    200: UserToken;
};

export type ApiUserTokensIdGetResponse = ApiUserTokensIdGetResponses[keyof ApiUserTokensIdGetResponses];

export type ApiVersionsGetCollectionData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The collection page number
         */
        page?: number;
        /**
         * The number of items per page
         */
        itemsPerPage?: number;
        /**
         * The name of the resource.
         */
        resource: 'GatewayCharge' | 'GatewayCheckout' | 'User';
        /**
         * The ID of the named resource.
         */
        resourceId: number;
    };
    url: '/v4/versions';
};

export type ApiVersionsGetCollectionResponses = {
    /**
     * Version collection
     */
    200: Array<Version>;
};

export type ApiVersionsGetCollectionResponse = ApiVersionsGetCollectionResponses[keyof ApiVersionsGetCollectionResponses];

export type ApiVersionsIdGetData = {
    body?: never;
    path: {
        /**
         * Version identifier
         */
        id: string;
    };
    query?: never;
    url: '/v4/versions/{id}';
};

export type ApiVersionsIdGetErrors = {
    /**
     * Not found
     */
    404: ErrorJsonld;
};

export type ApiVersionsIdGetError = ApiVersionsIdGetErrors[keyof ApiVersionsIdGetErrors];

export type ApiVersionsIdGetResponses = {
    /**
     * Version resource
     */
    200: Version;
};

export type ApiVersionsIdGetResponse = ApiVersionsIdGetResponses[keyof ApiVersionsIdGetResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};